#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
LIONZ Resources
---------------

This module contains utility functions and resources that are crucial for the operations of the LIONZ application.

LIONZ stands for Lesion segmentatION, a sophisticated solution for lesion segmentation tasks in medical imaging datasets. The resources module is designed to manage and provide auxiliary resources, such as configuration files, model weights, and other important artifacts necessary for the proper functioning of the application.

.. moduleauthor:: Lalith Kumar Shiyam Sundar <lalith.shiyamsundar@meduniwien.ac.at>
.. versionadded:: 0.1.0
"""

import torch
from lionz import constants

# List of available models in the LIONZ application
AVAILABLE_MODELS = ["fdg", "psma"]

# Dictionary of expected modalities for each model in the LIONZ application
EXPECTED_MODALITIES = {"fdg": ["PT", "CT"],
                       "psma": ["PT"]}

"""
TRACER_WORKFLOWS Dictionary Structure:

This dictionary organizes different workflows for various radiotracers used in PET and CT imaging.
The main goal is to facilitate the processing of different types of images based on their tracer and modality.

- Top-level keys represent different radiotracers, e.g., 'fdg', 'psma'.
- Each tracer has one or more 'workflows' associated with it.
- Each 'workflow' is represented by a key, e.g., 'pet_ct' or 'pet'.
- Inside each workflow, there's a 'channels' dictionary that specifies the image channels and their corresponding file
 extensions.

Structure:
{
    'tracer_name': {
        'workflows': {
            'workflow_name': {
                'channels': {
                    'channel_name': 'file_extension',
                    ...
                }
            },
            ...
        }
    },
    ...
}

Example:
For the 'fdg' tracer using the 'pet_ct' workflow:
- 'pet' images should have the file extension '0000.nii.gz'
- 'ct' images should have the file extension '0001.nii.gz'

This structure ensures modularity, making it easy to add new tracers, workflows, or modify existing ones.
"""

TRACER_WORKFLOWS = {
    'fdg': {
        'workflows': {
            'pet_ct': {
                'channels': {
                    'PT': '0000.nii.gz',
                    'CT': '0001.nii.gz'
                }
            },
            'pet': {
                'channels': {
                    'PT': '0000.nii.gz'
                }
            }
        }
    },
    # This structure allows for easy addition of more tracers with distinct workflows and channels.
    'psma': {
        'workflows': {
            'pet': {
                'channels': {
                    'PT': '0000.nii.gz'
                }
            }
        }
    }
}

# This dictionary holds the pre-trained models available in MooseZ library.
# Each key is a unique model identifier following a specific syntax mentioned above
# It should have the same name mentioned in AVAILABLE_MODELS list.
# Each value is a dictionary containing the following keys:
#    - url: The URL where the model files can be downloaded.
#    - filename: The filename of the model's zip file.
#    - directory: The directory where the model files will be extracted.
#    - trainer: The type of trainer used to train the model.
#    - voxel_spacing: The voxel spacing used in the model in the form [x, y, z], this is basically the median voxel
#    spacing generated by nnunetv2, and you can find this in the plans.json file of the model.
#    - multilabel_prefix: A prefix to distinguish between different types of labels in multi-label models.
#
# To include your own model, add a new entry to this dictionary following the above format.

MODELS = {
    "fdg": [
        {
            "url": "https://lionz.s3.eu.cloud-object-storage.appdomain.cloud/Dataset789_Tumors_all_organs_LION-DA5-2000.zip", #pet_ct
            "filename": "Dataset789_Tumors_all_organs_LION-DA5-2000.zip",
            "directory": "Dataset789_Tumors_all_organs_LION-DA5-2000",
            "trainer": "nnUNetTrainerDA5",
            "voxel_spacing": ["3", "3", "3"],
            "multilabel_prefix": "fdg_tumor_01_"
        },
        {
            "url": "https://lionz.s3.eu.cloud-object-storage.appdomain.cloud/clin_pt_fdg_tumor_16082023.zip",
            "filename": "Dataset804_Tumors_all_organs.zip",
            "directory": "Dataset804_Tumors_all_organs",
            "trainer": "nnUNetTrainerDA5",
            "voxel_spacing": ["3", "3", "3"],
            "multilabel_prefix": "fdg_tumor_"
        }
    ],
    "psma": [
        {
            "url": "PLACEHOLDER_URL_FOR_MODEL",
            "filename": "PLACEHOLDER_FILENAME",
            "directory": "PLACEHOLDER_DIRECTORY",
            "trainer": "PLACEHOLDER_TRAINER",
            "voxel_spacing": ["PLACEHOLDER_X", "PLACEHOLDER_Y", "PLACEHOLDER_Z"],
            "multilabel_prefix": "PLACEHOLDER_PREFIX"
        }
    ],
    # Add more tracers as needed, following the same structure
}



def check_cuda() -> str:
    """
    This function checks if CUDA is available on the device and prints the device name and number of CUDA devices
    available on the device.

    Returns:
        str: The device to run predictions on, either "cpu" or "cuda".
    """
    if not torch.cuda.is_available():
        print(
            f"{constants.ANSI_ORANGE}CUDA not available on this device. Predictions will be run on CPU.{constants.ANSI_RESET}")
        return "cpu"
    else:
        device_count = torch.cuda.device_count()
        print(
            f"{constants.ANSI_GREEN} CUDA is available on this device with {device_count} GPU(s). Predictions will be run on GPU.{constants.ANSI_RESET}")
        return "cuda"
